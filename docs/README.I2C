Libmpsse supports configuring FTDI chips as I2C master devices in order to communicate with I2C slave devices.

When initializing libmpsse, you must specify:

	1) That you wish to use the I2C mode
	2) The I2C clock frequency
	3) The data transfer endianess (I2C is always MSB first)

After initialization, you can communicate with any connected I2C slave device. A standard I2C transaction involves:

	1) Sending a start condition to indicate the beginning of a transaction
        2) Reading / writing data to and from the slave device
	3) Sending a re-start condition, if necessary
	4) Sending and recieving ACK/NACK bits
        5) Sending a stop condition to indicate the end of a transaction

Finally, once you are finished talking to your I2C slave device you must close the connection to the FTDI chip.

The following is a simple example of using I2C in Python:

	MPSSE(I2C, FOUR_HUNDRED_KHZ, MSB)	# Initialize libmpsse for I2C operations at 400kHz
	Start()					# Send the start condition
	Write("\xA0")				# Write one byte to the I2C slave
	if GetAck() == 0:			# Make sure the last written byte was acknowledged
		Start()				# Send a re-start condition
		data = Read(1)			# Read one byte from the I2C slave
		SetAck(1)			# Respond with a NACK for all subsequent reads
		data += Read(1)			# Read one last byte from the I2C slave
	Stop()					# Send I2C stop condition
	Close()					# Deinitialize libmpsse

A few notes regarding the above code:

	1) Acknowledge bits are read/sent automatically by the Read and Write functions. The GetAck() function does not
	   need to be called in order to generate or read acknowledgement bits; it simply returns the state of the last
	   received acknowledgement bit (0 == ACK, 1 == NACK).

	2) By default, Read will acknowledge all bytes that it receives. You can instruct Read to not acknowledge received
	   bytes by using the SetAck function, as shown in the example above. Setting SetAck to 1 will send NACKs; setting
	   SetAck to 0 will send ACKs. The default is 0 (send ACKs).

	3) Repeated start conditions are generated the same way that the first start condition was generated: by calling Start.
